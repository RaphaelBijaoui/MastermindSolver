#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <map>
#include <future>         // std::async, std::future
#include <chrono>

/// you can add other headers as needed
/// but only headers from the standard library
/// and not the algorithm header

/// do not use using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);
bool block_of_main(int length, int num);

/// you can define and use additional functions and structs,
/// add here the declarations for any other functions
/// and/or structs you wish to define and use
/// (the implementation for functions that don't belong to a struct
/// should be added after the main)

/// this is the struct definition for the code maker
/// do not alter the name
struct mm_code_maker{

    /// this member function sets the values for the member data
    /// representing the length of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter this function
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    /// do not alter this function
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

    /// do not alter the function interface (name, parameter list, void return)
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){

      std::vector<int> copy_of_attempt;
      copy_of_attempt = attempt;
      std::vector<int> copy_of_sequence;
      copy_of_sequence = sequence;
      black_hits = 0;
      white_hits = 0;

      for(int index = 0; index<sequence.size();index++){
        if(copy_of_attempt[index]==copy_of_sequence[index]){
          black_hits++;
          copy_of_attempt[index] = -1; // we set index to an impossible value, -1
          copy_of_sequence[index] = -2; // to be sure we don't check same variable twice
        }
      }

      for(int index = 0; index<copy_of_sequence.size();index++){
        if(copy_of_attempt[index] != -1){
          //save current value
          //iterate through sequence, if it's present
          // white ++, set to -1
          for(int element = 0; element < copy_of_sequence.size();element++){
            if(copy_of_attempt[index] == copy_of_sequence[element]){
              white_hits++;
              copy_of_attempt[index] = -1; //we set the checked values to -1
              copy_of_sequence[element] = -2; //note how the 2 sequences have different index.
            }
          }
        }
      }
    }

    /// member data holding the sequence generated by generate_sequence
    /// do not alter this
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    /// do not alter these
    int length;
    int num;

    /// do not add any other member data,
    /// in particular note that any variables needed for function give_feedback
    /// need to be declared within give_feedback
    /// (they are not member data of the struct)

    /// you may add other member functions if needed
};


/// this is the struct definition for the solver, do not alter the name
struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter the function interface (name, parameter list, void return)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        set_up = false;
        /// you can include additional implementation lines here if needed
    }

    /// this member function creates an attempt to find the right code
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void create_attempt(std::vector<int>& attempt){
      if(!set_up){
        //std::cout << "Value of set up was: "<<set_up<< std::endl;
        generate_initial_attempt();
        attempt = current_attempt;
        populate_list_of_all_numbers();
        //std::cout << "List populated"<< std::endl;
        populate_list_of_possible_solutions();
        //std::cout << "Possible solutions populated"<< std::endl;
        set_up = true;
        //std::cout << "Value of set up is now: "<<set_up<< std::endl;
      }
      else{
        pick_next_guess();
        attempt = current_attempt;
      }
    }

    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
      prune_list_of_possible_solutions(black_hits,white_hits);
      populate_list_of_next_guess(); //is this inefficient?
    }

    void populate_list_of_all_numbers(){
      std::vector<int> current_number(length, 0); //create vector of size n, all values 0 (starting point)
      std::vector<int> digit_iterator; //to hold values 0 - num-1

      for (int i = 0; i < num; ++i) {
        digit_iterator.push_back(i);
      }

      recursive_combination_generator(digit_iterator, current_number, 0, length);
    }

    void recursive_combination_generator(std::vector<int>& digit_iterator, std::vector<int>& current_number, int index, int length){
      if (index >= length) { //`Base case- when reached the last element
        list_of_all_numbers.push_back(current_number); //add last number to list
        return; //return, setting off chain until 0 reached
      }

      for (int j = 0; j < digit_iterator.size(); ++j) { //for values 0 - num-1
        current_number[index] = digit_iterator[j]; //current_number at index set to 0,1,2..
        recursive_combination_generator(digit_iterator,current_number, index + 1, length); //continue, moving onto next index
      }
      return;
    }

    void generate_initial_attempt(){
      int half_length = length/2;
      int zero = 0;
      int one = 1;

      for(int i = 0; i<length; i++){
        if(i<half_length){
          current_attempt.push_back(zero);
        }
        else{
          current_attempt.push_back(one);
        }
      }
      //std::cout << "Initial attempt: "<<std::endl;
      //print_vector(current_attempt);

    }

    //populates list_of_all_numbers with all items of list_of_possible_solutions.
    //must be called AFTER populate_list_of_all_numbers
    void populate_list_of_possible_solutions(){
      for(int i = 0; i<list_of_all_numbers.size();i++){
        list_of_possible_solutions.push_back(list_of_all_numbers[i]);
      }
    }

    //takes latest attempt, and it's feedback, and edits list accordingly
    void prune_list_of_possible_solutions(int black_hits, int white_hits){
      int temp_black_hits;
      int temp_white_hits;
      int vector_size = list_of_possible_solutions.size();
      std::vector<int> test_attempt = current_attempt;

      for(int i = 0; i<list_of_possible_solutions.size();i++){
        temp_black_hits = 0; //reset to value
        temp_white_hits = 0;

        give_feedback_solver(list_of_possible_solutions[i],temp_black_hits,temp_white_hits,test_attempt); //edits black and white hits

        if((temp_black_hits!=black_hits)||(temp_white_hits!=white_hits)){ //if not the same as before
            list_of_possible_solutions[i] = list_of_possible_solutions.back(); //swap last element with current element
            list_of_possible_solutions.pop_back();//remove last element of vector
            i = i - 1;
        }
        else{
          //std::cout<<"Possible solution: ";
          //print_vector(list_of_possible_solutions[i]);
          //std::cout<<" Current attempt: ";
          //print_vector(current_attempt);

        }
      }
    }

    void print_twod_vector(std::vector<std::vector<int>>& list_of_numbers){
      for(int i = 0; i<list_of_numbers.size();i++){
        print_vector(list_of_numbers[i]);
      }
      std::cout<<std::endl;
    }

    void print_vector(std::vector<int>& attempt){
      for(int x = 0; x<attempt.size(); x++){
          std::cout<<attempt[x];
      }
      std::cout<<std::endl;
    }

    void give_feedback_solver(const std::vector<int>& attempt, int& black_hits, int& white_hits, const std::vector<int>& alt_sequence){
        /// takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)

        std::vector<int> copy_of_attempt;
        copy_of_attempt = attempt;
        std::vector<int> copy_of_sequence;
        copy_of_sequence = alt_sequence;

        for(int index = 0; index<copy_of_sequence.size();index++){
          if(copy_of_attempt[index]==copy_of_sequence[index]){
            black_hits++;
            copy_of_attempt[index] = -1; // we set index to an impossible value, -1
            copy_of_sequence[index] = -2; // to be sure we don't check same variable twice
          }
        }

        for(int index = 0; index<copy_of_sequence.size();index++){
          if(copy_of_attempt[index] != -1){
            //save current value
            //iterate through sequence, if it's present
            // white ++, set to -1
            for(int element = 0; element < copy_of_sequence.size();element++){
              if(copy_of_attempt[index] == copy_of_sequence[element]){
                white_hits++;
                copy_of_attempt[index] = -1; //we set the checked values to -1
                copy_of_sequence[element] = -2; //note how the 2 sequences have different index.
              }
            }
          }
        }
    }

    //left digit = black hit, right digit = white hit
    std::string get_permutation_string(int black_hits, int white_hits){
      std::string permutation;
      permutation.append(std::to_string(black_hits));
      permutation.append(std::to_string(white_hits));

      return permutation;
    }
    //!!CHANGE NAMES!!
    int getMinScore(std::map<std::vector<int>,int> score){

      std::map<std::vector<int>, int>::iterator item;
      int min = 2147483647;

      for(item = score.begin(); item != score.end(); item++ ){
        if(item->second<min){
          min = item->second;
        }
      }

      return min;
    }

    //!!!CHANGE NAMES!!!
    int getMaxScore(std::map<std::string,int>& scoreCount){

      std::map<std::string, int>::iterator item;
      int max = 0;

      for(item = scoreCount.begin(); item != scoreCount.end(); item++ ){
        if(item->second>max){
          max = item->second;
        }
      }

      return max;
    }

    //iterates through all numbers, looking at how each element reacts with whole possible solutions
    // !!CHANGE NAMES!!
    void populate_list_of_next_guess(){
      std::map<std::string, int> scoreCount;
      std::map<std::vector<int>,int> score;
      std::string pegScore;
      int black_hits, white_hits;

      int max,min;

      for(int i = 0; i<list_of_all_numbers.size();i++){

        for(int j = 0; j<list_of_possible_solutions.size();j++){
          black_hits = 0;
          white_hits = 0;
          give_feedback_solver(list_of_all_numbers[i], black_hits, white_hits, list_of_possible_solutions[j]);
          pegScore = get_permutation_string(black_hits,white_hits);

          if(scoreCount.count(pegScore)>0){ //count() searches scoreCount if pegscore is unique
            scoreCount.at(pegScore)++;
          }
          else{ //if not unique,
            scoreCount.emplace(pegScore,1); //Add the pegscore to the left, and a 1 for
          }
        }

        max = getMaxScore(scoreCount); //take worst-case scenario
        score.emplace(list_of_all_numbers[i],max);
        scoreCount.clear();
      }

      min = getMinScore(score); //pick the best worst-case scenario

      for(std::map<std::vector<int>, int>::iterator item = score.begin(); item != score.end(); item++ ){ //for all elements in score
        if(item->second==min){ //if the item's
          list_of_next_guess.push_back(item->first);
        }
      }
    }

    //changes current_attempt to next guess
    void pick_next_guess(){
      std::vector<int> guess = current_attempt;

      for(int i = 0; i<list_of_next_guess.size(); i++){
        if(in_list_of_possible_solutions(list_of_next_guess[i])){
          current_attempt = list_of_next_guess[i];
        }
      }
      if(guess==current_attempt){
        for(int j = 0; j<list_of_next_guess.size();j++){
          if(in_list_of_all_numbers(list_of_next_guess[j])){
            current_attempt = list_of_next_guess[j];
          }
        }
      }
    }

    bool in_list_of_possible_solutions(std::vector<int> next_guess){

      for(int i = 0; i<list_of_possible_solutions.size();i++){
        if(list_of_possible_solutions[i]==next_guess){
          return true;
        }
      }

      return false;
    }

    bool in_list_of_all_numbers(std::vector<int> next_guess){
      for(int i = 0; i<list_of_all_numbers.size();i++){
        if(list_of_all_numbers[i]==next_guess){
          return true;
        }
      }

      return false;
    }

    int length;
    int num;
    std::vector<std::vector<int>> list_of_all_numbers;
    std::vector<std::vector<int>> list_of_possible_solutions;
    std::vector<std::vector<int>> list_of_next_guess;
    std::vector<int> current_attempt;
    bool set_up;

    /// you may add other member functions and member data as needed
    /// (keep in mind the distinction between member function variables
    /// and member data of the struct)

};

int main(){
    set_random_seed();

    int length, num, games, max, min;
    double max_time, min_time;
    max = 0;
    min = 1000; // this is attempts limit

    max_time = 0;
    min_time = 1000000;


    std::vector<int> attempts_values;
    std::vector<double> time_values;

    //std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;

    //std::cout << "enter number of tests:" << std::endl;
    std::cin >> games;

    for(int i=0; i<games; i++){

        std::clock_t start, start_in;
        double duration;

        start = std::clock();

        mm_solver solver;
        solver.init(length, num);

        mm_code_maker maker;
        maker.init(length, num);

        maker.generate_sequence();

        int black_hits=0, white_hits=0;

        int attempts_limit = 1000;

        int attempts = 0;

        while((black_hits < length) && (attempts < attempts_limit)){
            std::vector<int> attempt;

            start_in = std::clock();

            solver.create_attempt(attempt);

            maker.give_feedback(attempt, black_hits, white_hits);

            //std::cout << "attempt: " << attempts <<std::endl;
            //for(int i = 0; i < attempt.size(); i++){
            //    std::cout << attempt[i] << " ";
            //}
            //std::cout << std::endl;

            //std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;

            solver.learn(attempt, black_hits, white_hits);

            duration = ( std::clock() - start_in ) / (double) CLOCKS_PER_SEC;

            //std::cout<<"time to learn: "<<duration<<std::endl<<std::endl;

            attempts++;
        }

        duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC;
        time_values.push_back(duration);
        //std::cout<<"TIME TAKEN: "<<duration<<std::endl;

        if(black_hits == length){
            //std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
        }
        else{
            //std::cout << "after " << attempts << " attempts still no solution" << std::endl;
        }

        //std::cout << "the sequence generated by the code maker was:" << std::endl;
        for(int i = 0; i < maker.sequence.size(); i++){
            //std::cout << maker.sequence[i] << " ";
        }
        //std::cout << std::endl;

        attempts_values.push_back(attempts);

        if(attempts>max){
            max = attempts;
        }

        if(attempts<min){
            min = attempts;
        }

        if(duration>max_time){
            max_time = duration;
        }

        if(duration<min_time){
            min_time = duration;
        }

    }

    double average = 0;
    double average_time = 0;

    for(int i=0; i<attempts_values.size(); i++){
        average = average + attempts_values[i];
    }

    average = average/attempts_values.size();

    for(int i=0; i<time_values.size(); i++){
        average_time = average_time + time_values[i];
    }

    average_time = average_time/time_values.size();

    std::cout<<"Length: "<<length<<" Num: "<<num<<" Games: "<<games<<std::endl;

    std::cout<<"average attempts: "<<average<<std::endl;
    std::cout<<"max: "<<max<<std::endl;
    std::cout<<"min: "<<min<<std::endl;

    std::cout<<"average time: "<<average_time<<std::endl;
    std::cout<<"max: "<<max_time<<std::endl;
    std::cout<<"min: "<<min_time<<std::endl;


    return 0;
}

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}

/// add here the implementation for any other functions you wish to define and use
