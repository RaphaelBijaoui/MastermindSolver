#include <iostream>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <map>
#include <chrono>

//not using namespace std

/// functions for random number generation, do not alter the declarations
void set_random_seed();
int randn(int n);
bool block_of_main(int length, int num);


/// this is the struct definition for the code maker
struct mm_code_maker{

    /// this member function sets the values for the member data
    /// representing the length of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)

    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
    }

    /// this member function generates a random sequence based
    /// on the length and num parameters stored as member data
    void generate_sequence(){
        for(int i = 0; i < length; i++){
            sequence.push_back(randn(num));
        }
    }

    /// do not alter the function interface (name, parameter list, void return)
    void give_feedback(const std::vector<int>& attempt, int& black_hits, int& white_hits){

      std::vector<int> copy_of_attempt;
      copy_of_attempt = attempt;
      std::vector<int> copy_of_sequence;
      copy_of_sequence = sequence;
      black_hits = 0;
      white_hits = 0;

      for(int index = 0; index<sequence.size();index++){
        if(copy_of_attempt[index]==copy_of_sequence[index]){
          black_hits++;
          copy_of_attempt[index] = -1; // we set index to an impossible value, -1
          copy_of_sequence[index] = -2; // to be sure we don't check same variable twice
        }
      }

      for(int index = 0; index<copy_of_sequence.size();index++){
        if(copy_of_attempt[index] != -1){
          //save current value
          //iterate through sequence, if it's present
          // white ++, set to -1
          for(int element = 0; element < copy_of_sequence.size();element++){
            if(copy_of_attempt[index] == copy_of_sequence[element]){
              white_hits++;
              copy_of_attempt[index] = -1; //we set the checked values to -1
              copy_of_sequence[element] = -2; //note how the 2 sequences have different index.
            }
          }
        }
      }
    }

    /// member data holding the sequence generated by generate_sequence
    std::vector<int> sequence;

    /// member data holding the values for length of code and number of symbols
    int length;
    int num;

    /// in particular note that any variables needed for function give_feedback
    /// need to be declared within give_feedback
    /// (they are not member data of the struct)

};


struct mm_solver{

    /// this member function sets the values for the member data
    /// representing the lenght of the code
    /// and the number of symbols (the symbols will be 0 to i_num - 1)
    /// (this should be a constructor in proper OOP but ok)
    /// do not alter the function interface (name, parameter list, void return)
    void init(int i_length, int i_num){
        length = i_length;
        num = i_num;
        set_up = false;
        deductive_set_up=false;
        counter = 0;
        set_difficulty();
        /// you can include additional implementation lines here if needed
    }

    /// this member function creates an attempt to find the right code
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void create_attempt(std::vector<int>& attempt){
      if(!set_up){
        //std::cout << "Value at set up was: "<<set_up<< std::endl;
        generate_initial_attempt();
        attempt = current_attempt;
        if(difficulty==0 || difficulty==1){
          populate_list_of_all_numbers();
          //std::cout << "List populated."<< std::endl;
          populate_list_of_possible_solutions();
        }
        if(difficulty==2){
          for(int i = 0; i<length;i++){
            deductive_vector.push_back(0); //set up vector to initial state for deductive_logic solver
          }
        }
        set_up = true;
      }
      else{
        pick_next_guess();
        attempt = current_attempt;
      }
    }

    /// this member function acquires the feedback about a certain attempt
    /// (see the other examples provided for clarifications)
    /// do not alter the function interface (name, parameter list, void return)
    void learn(std::vector<int>& attempt, int black_hits, int white_hits){
      if(difficulty==0){
        prune_list_of_possible_solutions(black_hits,white_hits);
        minimax_populate_list_of_next_guess();
      }
      if(difficulty==1){
        prune_list_of_possible_solutions(black_hits,white_hits);
      }
      if(difficulty==2){
        deductive_logic_step(black_hits,white_hits); //sets next deductive guess
      }
    }

    void populate_list_of_all_numbers(){
      std::vector<int> current_number(length, 0); //create vector of size n, all values 0 (starting point)
      std::vector<int> digit_iterator; //to hold values 0 - num-1

      for (int i = 0; i < num; ++i) {
        digit_iterator.push_back(i);
      }

      recursive_combination_generator(digit_iterator, current_number, 0, length);
    }

    void recursive_combination_generator(std::vector<int>& digit_iterator, std::vector<int>& current_number, int index, int length){
      if (index >= length) { //`Base case- when reached the last element
        list_of_all_numbers.push_back(current_number); //add last number to list
        return; //return, setting off chain until 0 reached
      }

      for (int j = 0; j < digit_iterator.size(); ++j) { //for values 0 - num-1
        current_number[index] = digit_iterator[j]; //current_number at index set to 0,1,2..
        recursive_combination_generator(digit_iterator,current_number, index + 1, length); //continue, moving onto next index
      }
      return;
    }

    void generate_initial_attempt(){
      int half_length = length/2;

      if((difficulty==0)||(difficulty==1)){
       for(int i = 0; i<length; i++){
        if(i<half_length){
          current_attempt.push_back(0);
        }
        else{
          current_attempt.push_back(1);
        }
       }
      }
      if(difficulty==2){
        for(int i = 0; i<length; i++){
           current_attempt.push_back(0);
        }
      }
    }

    //populates list_of_all_numbers with all items of list_of_possible_solutions.
    //must be called AFTER populate_list_of_all_numbers
    void populate_list_of_possible_solutions(){
      for(int i = 0; i<list_of_all_numbers.size();i++){
        list_of_possible_solutions.push_back(list_of_all_numbers[i]);
      }
    }

    //takes latest attempt, and it's feedback, and edits list accordingly
    void prune_list_of_possible_solutions(int black_hits, int white_hits){
      int temp_black_hits;
      int temp_white_hits;
      int vector_size = list_of_possible_solutions.size();
      std::vector<int> test_attempt = current_attempt;

      for(int i = 0; i<list_of_possible_solutions.size();i++){
        temp_black_hits = 0; //reset to value
        temp_white_hits = 0;

        give_feedback_solver(list_of_possible_solutions[i],temp_black_hits,temp_white_hits,test_attempt); //edits black and white hits

        if((temp_black_hits!=black_hits)||(temp_white_hits!=white_hits)){ //if not the same as before
            list_of_possible_solutions[i] = list_of_possible_solutions.back(); //swap last element with current element
            list_of_possible_solutions.pop_back();//remove last element of vector
            i = i - 1;
        }
      }
    }

    //for testing purposes
    void print_twod_vector(std::vector<std::vector<int>>& list_of_numbers){
      for(int i = 0; i<list_of_numbers.size();i++){
        print_vector(list_of_numbers[i]);
      }
      std::cout<<std::endl;
    }

    //for testing purposes
    void print_vector(std::vector<int>& attempt){
      for(int x = 0; x<attempt.size(); x++){
          std::cout<<attempt[x];
      }
      std::cout<<std::endl;
    }

    //give feedback for solver, instead of maker. This allows us to compare possible solution with all solution (Knuth)
    void give_feedback_solver(const std::vector<int>& attempt, int& black_hits, int& white_hits, const std::vector<int>& alt_sequence){
        /// takes in input an attempt
        /// and provides feedback in terms of black hits
        /// and white hits (see linked paper)

        std::vector<int> copy_of_attempt;
        copy_of_attempt = attempt;
        std::vector<int> copy_of_sequence;
        copy_of_sequence = alt_sequence;

        for(int index = 0; index<copy_of_sequence.size();index++){
          if(copy_of_attempt[index]==copy_of_sequence[index]){
            black_hits++;
            copy_of_attempt[index] = -1; // we set index to an impossible value, -1
            copy_of_sequence[index] = -2; // to be sure we don't check same variable twice
          }
        }

        for(int index = 0; index<copy_of_sequence.size();index++){
          if(copy_of_attempt[index] != -1){
            //save current value
            //iterate through sequence, if it's present
            // white ++, set to -1
            for(int element = 0; element < copy_of_sequence.size();element++){
              if(copy_of_attempt[index] == copy_of_sequence[element]){
                white_hits++;
                copy_of_attempt[index] = -1; //we set the checked values to -1
                copy_of_sequence[element] = -2; //note how the 2 sequences have different index.
              }
            }
          }
        }
    }

    //left digit = black hit, right digit = white hit
    std::string get_permutation_string(int black_hits, int white_hits){
      std::string permutation;
      permutation.append(std::to_string(black_hits));
      permutation.append(std::to_string(white_hits));

      return permutation;
    }

    int set_minimum(std::map<std::vector<int>,int> table_of_overall_worst_cases){

      std::map<std::vector<int>, int>::iterator item;
      int min = 2147483647; //set minimum to maximum integer value to avoid collision

      for(item = table_of_overall_worst_cases.begin(); item != table_of_overall_worst_cases.end(); item++ ){ //iterating through table
        if(item->second<min){
          min = item->second;
        }
      }

      return min;
    }

    int set_maximum(std::map<std::string,int>& table_of_individual_scores){

      std::map<std::string, int>::iterator item;
      int max = 0;

      for(item = table_of_individual_scores.begin(); item != table_of_individual_scores.end(); item++ ){
        if(item->second>max){
          max = item->second;
        }
      }

      return max;
    }

    //iterates through all numbers, looking at how each element reacts with whole possible solutions
    void minimax_populate_list_of_next_guess(){
      std::map<std::string, int> table_of_individual_scores; //for each permutation in list_of_all_numbers
      std::map<std::vector<int>,int> table_of_overall_worst_cases; //holds worst-case scenario of each number, taken from table_of_individual_scores table
      std::string hit_combination;
      int black_hits, white_hits;

      int max,min;

      for(int i = 0; i<list_of_all_numbers.size();i++){

        for(int j = 0; j<list_of_possible_solutions.size();j++){
          black_hits = 0;
          white_hits = 0;
          give_feedback_solver(list_of_all_numbers[i], black_hits, white_hits, list_of_possible_solutions[j]);
          hit_combination = get_permutation_string(black_hits,white_hits);

          if(table_of_individual_scores.count(hit_combination)>0){ //count() searches table_of_individual_scores if hit_combination is unique
            table_of_individual_scores.at(hit_combination)++;
          }
          else{ //if not unique,
            table_of_individual_scores.emplace(hit_combination,1); //Add the hit_combination to the left, and a 1 for the first count
          }
        }

        max = set_maximum(table_of_individual_scores); //take worst-case scenario
        table_of_overall_worst_cases.emplace(list_of_all_numbers[i],max);
        table_of_individual_scores.clear();
      }

      min = set_minimum(table_of_overall_worst_cases); //pick the best worst-case scenario

      for(std::map<std::vector<int>, int>::iterator item = table_of_overall_worst_cases.begin(); item != table_of_overall_worst_cases.end(); item++ ){ //for all elements in table_of_overall_worst_cases
        if(item->second==min){ //if the item in the table is the minimum of the maximum scores
          list_of_next_guess.push_back(item->first); //add it to the list of next guesses
        }
      }
    }

    //changes current_attempt to next guess
    void pick_next_guess(){
      std::vector<int> guess = current_attempt;
      int n, random_index;

     if(difficulty==0){ //Knuth with minimax
      for(int i = 0; i<list_of_next_guess.size(); i++){
        if(in_list_of_possible_solutions(list_of_next_guess[i])){ //if worst-case scenario is in list of possible solutions
          current_attempt = list_of_next_guess[i]; //set attempt to that value
        }
      }
      if(guess==current_attempt){ //If guess is not in the list of next_guesses,
        for(int j = 0; j<list_of_next_guess.size();j++){
          if(in_list_of_all_numbers(list_of_next_guess[j])){ //check if the next guess is in the list of all numbers
            current_attempt = list_of_next_guess[j]; //set attempt to that value
          }
        }
      }
     }

     if(difficulty==1){ //Knuth without minimax
       n = list_of_possible_solutions.size();
       random_index = randn(n);
       current_attempt = list_of_possible_solutions[random_index];
     }
     if(difficulty==2){
      current_attempt = deductive_vector;
     }
    }

    bool in_list_of_possible_solutions(std::vector<int> next_guess){

      for(int i = 0; i<list_of_possible_solutions.size();i++){
        if(list_of_possible_solutions[i]==next_guess){
          return true;
        }
      }

      return false;
    }

    bool in_list_of_all_numbers(std::vector<int> next_guess){
      for(int i = 0; i<list_of_all_numbers.size();i++){
        if(list_of_all_numbers[i]==next_guess){
          return true;
        }
      }

      return false;
    }

    //sets the difficulty of game, based off tests
    void set_difficulty(){

      //if in the red zone (from tests)
     if((length==6&&num>13)||(length==7&&num>10)||(length==8&&num>=8)||(length==9&&num>6)||(length==10&&num>=5)||(length==11&&num>=5)||(length==12&&num>=4)||(length==13&&num>=4)||(length==14&&num>=3)||(length==15&&num>=3)){
       difficulty = 2; //set to brute force
     }
     else{ //if in orange zone
      if((length==4&&num>=11)||(length==5&&num>=7)||(length==6&&num==3&&num<=13)||(length==7&&num>=2&&num<=9)||(length==8 && num>=4 && num<=7)||(length==9 && num>=4 && num<=5)||(length==10 && num>=3 && num<=4)||(length==11 && num>=3 && num<=4)||(length==12 && num==3)||(length==13 && num==3)||(length==15 && num==2)){
        difficulty = 1; //set to knuth without minimax
      }
      else{ //if in green zone
        difficulty = 0; //set to knuth
      }
     }
    }

    //Solving Mastermind through deduction for larger numbers
    void deductive_logic_step(int black_hits, int white_hits){
      if(!deductive_set_up){
        vector_index = 0;
        counter = 1;
        deductive_vector[vector_index]=counter;
        deductive_set_up=true;
      }
      else{
          if(black_hits==(previous_black-1)){}
          if(black_hits==(previous_black+1)){
            vector_index++;
            counter = 1;
            deductive_vector[vector_index] = counter;
          }
          else{
            if(counter<num){
              deductive_vector[vector_index] = counter;
              counter++;
            }
            else{
              if(counter >= num){ //if counter is the maximum number
                counter = 0;
                deductive_vector[vector_index] = counter;
              }
            }
          }
      }
      previous_black = black_hits;
      current_attempt = deductive_vector;
    }

    //For whole program
    int length; //used across program, set by init
    int num; //used across program, set by init
    int difficulty; //holds difficulty of sequence set by set_difficulty (called in init)
    std::vector<int> current_attempt;  //Variable sets value of attempt
    bool set_up; //Defined in init. Differentiator between set up stage and following guesses.

    //For deductive_logic algorithm
    int previous_black; //
    int counter; // defined in init
    int vector_index; //for iteration up the vector
    bool deductive_set_up; // check for if deductive_logic_step function is set up
    std::vector<int> deductive_vector; //holds next attempt of deductive_logic, sets current_attempt in next_guess()

    //For Knuth's algorithm
    std::vector<std::vector<int>> list_of_all_numbers;
    std::vector<std::vector<int>> list_of_possible_solutions;

    //For minimax implementation
    std::vector<std::vector<int>> list_of_next_guess;

};

int main(){
    set_random_seed();

    int length, num, games, max, min;
    double max_time, min_time;
    max = 0;
    min = 1000; // this is attempts limit

    max_time = 0;
    min_time = 1000000;


    std::vector<int> attempts_values;
    std::vector<double> time_values;

    //std::cout << "enter length of sequence and number of possible values:" << std::endl;
    std::cin >> length >> num;

    //std::cout << "enter number of tests:" << std::endl;
    std::cin >> games;

    for(int i=0; i<games; i++){

        std::clock_t start, start_in;
        double duration;

        start = std::clock();

        mm_solver solver;
        solver.init(length, num);

        mm_code_maker maker;
        maker.init(length, num);

        maker.generate_sequence();
        std::cout<<"Sequence generated"<<std::endl;

        int black_hits=0, white_hits=0;

        int attempts_limit = 100000;

        int attempts = 0;

        while((black_hits < length) && (attempts < attempts_limit)){
            std::vector<int> attempt;

            start_in = std::clock();

            solver.create_attempt(attempt);

            maker.give_feedback(attempt, black_hits, white_hits);

            std::cout << "attempt: " << attempts <<std::endl;
            for(int i = 0; i < attempt.size(); i++){
                std::cout << attempt[i] << " ";
            }
            std::cout << std::endl;

            //std::cout << "black pegs: " << black_hits << " " << " white pegs: " << white_hits << std::endl;

            solver.learn(attempt, black_hits, white_hits);

            duration = ( std::clock() - start_in ) / (double) CLOCKS_PER_SEC;

            //std::cout<<"time to learn: "<<duration<<std::endl<<std::endl;

            attempts++;
        }

        duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC;
        time_values.push_back(duration);
        //std::cout<<"TIME TAKEN: "<<duration<<std::endl;

        if(black_hits == length){
            //std::cout << "the solver has found the sequence in " << attempts << " attempts" << std::endl;
        }
        else{
            //std::cout << "after " << attempts << " attempts still no solution" << std::endl;
        }

        //std::cout << "the sequence generated by the code maker was:" << std::endl;
        for(int i = 0; i < maker.sequence.size(); i++){
            //std::cout << maker.sequence[i] << " ";
        }
        //std::cout << std::endl;

        attempts_values.push_back(attempts);

        if(attempts>max){
            max = attempts;
        }

        if(attempts<min){
            min = attempts;
        }

        if(duration>max_time){
            max_time = duration;
        }

        if(duration<min_time){
            min_time = duration;
        }

    }

    double average = 0;
    double average_time = 0;

    for(int i=0; i<attempts_values.size(); i++){
        average = average + attempts_values[i];
    }

    average = average/attempts_values.size();

    for(int i=0; i<time_values.size(); i++){
        average_time = average_time + time_values[i];
    }

    average_time = average_time/time_values.size();

    std::cout<<"Length: "<<length<<" Num: "<<num<<" Games: "<<games<<std::endl;

    std::cout<<"average attempts: "<<average<<std::endl;
    std::cout<<"max: "<<max<<std::endl;
    std::cout<<"min: "<<min<<std::endl;

    std::cout<<"average time: "<<average_time<<std::endl;
    std::cout<<"max: "<<max_time<<std::endl;
    std::cout<<"min: "<<min_time<<std::endl;


    return 0;
}

/// not a great implementation for set_random_seed and for randn;
/// if you are trying to get better results you may want to change
/// the implementation using C++11 features, see for instance
/// https://isocpp.org/files/papers/n3551.pdf
/// but don't change the interface/declaration of the functions

void set_random_seed(){
    std::srand(std::time(0));
}

int randn(int n){
    return std::rand() % n;
}
